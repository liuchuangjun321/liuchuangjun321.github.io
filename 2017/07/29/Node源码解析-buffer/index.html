<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="node," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="原文在这里。 在Node、ES2015出现之前，前端工程师只需要进行一些简单的字符串或DOM操作就可以满足业务需要，所以对二进制数据是比较陌生。node出现以后，前端面对的技术场景发生了变化，可以深入到网络传输、文件操作、图片处理等领域，而这些操作都与二进制数据紧密相关。 Node里面的buffer，是一个二进制数据容器，数据结构类似与数组，数组里面的方法在buffer都存在(slice操作的结果">
<meta name="keywords" content="node">
<meta property="og:type" content="article">
<meta property="og:title" content="Node源码解析---buffer">
<meta property="og:url" content="http://yoursite.com/2017/07/29/Node源码解析-buffer/index.html">
<meta property="og:site_name" content="Big Chuang&#39;s WebSite">
<meta property="og:description" content="原文在这里。 在Node、ES2015出现之前，前端工程师只需要进行一些简单的字符串或DOM操作就可以满足业务需要，所以对二进制数据是比较陌生。node出现以后，前端面对的技术场景发生了变化，可以深入到网络传输、文件操作、图片处理等领域，而这些操作都与二进制数据紧密相关。 Node里面的buffer，是一个二进制数据容器，数据结构类似与数组，数组里面的方法在buffer都存在(slice操作的结果">
<meta property="og:image" content="http://os20uatm3.bkt.clouddn.com/buffer%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://os20uatm3.bkt.clouddn.com/buffer%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png">
<meta property="og:updated_time" content="2017-07-30T14:01:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Node源码解析---buffer">
<meta name="twitter:description" content="原文在这里。 在Node、ES2015出现之前，前端工程师只需要进行一些简单的字符串或DOM操作就可以满足业务需要，所以对二进制数据是比较陌生。node出现以后，前端面对的技术场景发生了变化，可以深入到网络传输、文件操作、图片处理等领域，而这些操作都与二进制数据紧密相关。 Node里面的buffer，是一个二进制数据容器，数据结构类似与数组，数组里面的方法在buffer都存在(slice操作的结果">
<meta name="twitter:image" content="http://os20uatm3.bkt.clouddn.com/buffer%E7%BB%93%E6%9E%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/29/Node源码解析-buffer/"/>





  <title>Node源码解析---buffer | Big Chuang's WebSite</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?12cfbab09f3fcdee181cf994706182d5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Big Chuang's WebSite</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/29/Node源码解析-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大闯仔儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_2036.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Big Chuang's WebSite">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Node源码解析---buffer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T12:01:11+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文<a href="http://zhenhua-lee.github.io/node/buffer.html" target="_blank" rel="external">在这里</a>。</p>
<p>在Node、ES2015出现之前，前端工程师只需要进行一些简单的字符串或DOM操作就可以满足业务需要，所以对二进制数据是比较陌生。node出现以后，前端面对的技术场景发生了变化，可以深入到网络传输、文件操作、图片处理等领域，而这些操作都与二进制数据紧密相关。</p>
<p>Node里面的buffer，是一个<strong>二进制数据容器</strong>，数据结构类似与数组，数组里面的方法在buffer都存在(slice操作的结果不一样)。下面就从源码(v6.0版本)层面分析，揭 开buffer操作的面纱。</p>
<h2 id="buffer的基本使用"><a href="#buffer的基本使用" class="headerlink" title="buffer的基本使用"></a>buffer的基本使用</h2><p>在Node 6.0以前，直接使用<code>new Buffer</code>，但是这种方式存在两个问题:</p>
<ul>
<li>参数复杂: 内存分配，还是内存分配+内容写入，需要根据参数来确定</li>
<li>安全隐患: 分配到的内存可能还存储着旧数据，这样就存在安全隐患</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 本来只想申请一块内存，但是里面却存在旧数据</div><div class="line">const buf1 = new Buffer(10) // &lt;Buffer 90 09 70 6b bf 7f 00 00 50 3a&gt;</div><div class="line">// 不小心，旧数据就被读取出来了</div><div class="line">buf1.toString()  // &apos;�\tpk�\u0000\u0000P:&apos;</div></pre></td></tr></table></figure>
<p>为了解决上述问题，Buffer提供了<code>Buffer.from</code>、<code>Buffer.alloc</code>、<code>Buffer.allocUnsafe</code>、<code>Buffer.allocUnsafeSlow</code>四个方法来申请内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 申请10个字节的内存</div><div class="line">const buf2 = Buffer.alloc(10) // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</div><div class="line">// 默认情况下，用0进行填充</div><div class="line">buf2.toString() //&apos;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000&apos;</div><div class="line"></div><div class="line">// 上述操作就相当于</div><div class="line">const buf1 = new Buffer(10);</div><div class="line">buf.fill(0);</div><div class="line">buf.toString(); // &apos;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000&apos;</div></pre></td></tr></table></figure>
<h2 id="buffer的结构"><a href="#buffer的结构" class="headerlink" title="buffer的结构"></a>buffer的结构</h2><p>buffer是一个典型的javascript与c++结合的模块，其性能部分用c++实现，非性能部分用javascript来实现。</p>
<p><img src="http://os20uatm3.bkt.clouddn.com/buffer%E7%BB%93%E6%9E%84.png" alt="buffer结构"></p>
<p>下面看看buffer模块的内部结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exports.Buffer = Buffer;</div><div class="line">exports.SlowBuffer = SlowBuffer;</div><div class="line">exports.INSPECT_MAX_BYTES = 50;</div><div class="line">exports.kMaxLength = binding.kMaxLength;</div></pre></td></tr></table></figure>
<p>buffer模块提供了4个接口:</p>
<ul>
<li>Buffer: 二进制数据容器类，node启动时默认加载</li>
<li>SlowBuffer: 同样也是二进制数据容器类，不过直接进行内存申请</li>
<li>INSPECT_MAX_BYTES: 限制<code>bufObject.inspect()</code>输出的长度</li>
<li>kMaxLength: 一次性内存分配的上限，大小为(2^31 - 1)</li>
</ul>
<p>其中，由于Buffer经常使用，所以node在启动的时候，就已经加载了Buffer，而其他三个，仍然需要使用<code>require(&#39;buffer&#39;).***</code>。</p>
<p>关于buffer的内存申请、填充、修改等涉及性能问题的操作，均通过c++里面的node_buffer.cc来实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// c++里面的node_buffer</div><div class="line">namespace node &#123;</div><div class="line">  bool zero_fill_all_buffers = false;</div><div class="line">  namespace Buffer &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">NODE_MODULE_CONTEXT_AWARE_BUILTIN(buffer, node::Buffer::Initialize)</div></pre></td></tr></table></figure>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>Node中Buffer内存分配太过常见，从系统性能考虑出发，Buffer采用了如下的管理策略。</p>
<p><img src="http://os20uatm3.bkt.clouddn.com/buffer%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="buffer内存结构"></p>
<h3 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from"></a>Buffer.from</h3><p><code>Buffer.from(value,...)</code>用于申请内存，并将内容写入刚刚申请到的内存中，value值是多样的，Buffer是如何处理的呢，看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Buffer.from = function(value, encodingOrOffset, length) &#123;</div><div class="line">  if (typeof value === &apos;number&apos;)</div><div class="line">    throw new TypeError(&apos;&quot;value&quot; argument must not be a number&apos;);</div><div class="line"></div><div class="line">  if (value instanceof ArrayBuffer)</div><div class="line">    return fromArrayBuffer(value, encodingOrOffset, length);</div><div class="line"></div><div class="line">  if (typeof value === &apos;string&apos;)</div><div class="line">    return fromString(value, encodingOrOffset);</div><div class="line"></div><div class="line">  return fromObject(value);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>value可以分成三类:</p>
<ul>
<li>ArrayBuffer的实例: ArrayBuffer是ES2015里面引入的，用于在浏览器端直接操作二进制数据，这样Node就与ES2015关联起来，同时，新创建的Buffer与ArrayBuffer内存是共享的</li>
<li>string: 该方法实现了将字符串转变为Buffer</li>
<li>Buffer/TypeArray/Array: 会进行值的copy</li>
</ul>
<h4 id="ArrayBuffer的实例"><a href="#ArrayBuffer的实例" class="headerlink" title="ArrayBuffer的实例"></a>ArrayBuffer的实例</h4><p>Node v6与时俱进，将浏览器、node中对二进制数据的操作关联起来，同时二者会进行内存的共享。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var b = new ArrayBuffer(4);</div><div class="line">var v1 = new Uint8Array(b);</div><div class="line">var buf = Buffer.from(b)</div><div class="line">console.log(&apos;first, typeArray: &apos;, v1) // first, typeArray:  Uint8Array [ 0, 0, 0, 0 ]</div><div class="line">console.log(&apos;first, Buffer: &apos;, buf) // first, Buffer:  &lt;Buffer 00 00 00 00&gt;</div><div class="line">v1[0] = 12</div><div class="line">console.log(&apos;second, typeArray: &apos;, v1) // second, typeArray:  Uint8Array [ 12, 0, 0, 0 ]</div><div class="line">console.log(&apos;second, Buffer: &apos;, buf) // second, Buffer:  &lt;Buffer 0c 00 00 00&gt;</div></pre></td></tr></table></figure>
<p>在上述操作中，对ArrayBuffer的操作，引起Buffer值的修改，说明二者在内存上是同享的。</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>可以实现字符串与Buffer之间的转换，同时考虑到操作的性能，采用了一些优化策略避免频繁进行内存分配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function fromString(string, encoding) &#123;</div><div class="line">  ...</div><div class="line">  var length = byteLength(string, encoding);</div><div class="line">  if (length === 0)</div><div class="line">    return Buffer.alloc(0);</div><div class="line">  // 当字符所需要的字节数大于4KB时: 直接进行内存分配</div><div class="line">  if (length &gt;= (Buffer.poolSize &gt;&gt;&gt; 1))</div><div class="line">    return binding.createFromString(string, encoding);</div><div class="line">  // 当字符所需字节数小于4KB: 借助allocPool先申请、后分配的策略</div><div class="line">  if (length &gt; (poolSize - poolOffset))</div><div class="line">    createPool();</div><div class="line">  var actual = allocPool.write(string, poolOffset, encoding);</div><div class="line">  var b = allocPool.slice(poolOffset, poolOffset + actual);</div><div class="line">  poolOffset += actual;</div><div class="line">  alignPool();</div><div class="line">  return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>直接分配内存</li>
</ul>
<p>当字符串所需要的字节大于4KB时，直接进行内存分配。</p>
<ul>
<li>借助pool管理，先申请后分配</li>
</ul>
<p>用一个pool来管理频繁的行为，在计算机中是非常常见的行为，例如http模块中，关于tcp连接的建立，就设置了一个tcp pool。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function fromString(string, encoding) &#123;</div><div class="line">  ...</div><div class="line">  // 当字符所需字节数小于4KB: 借助allocPool先申请、后分配的策略</div><div class="line">  // pool的空间不够用，重新分配8kb的内存</div><div class="line">  if (length &gt; (poolSize - poolOffset))</div><div class="line">    createPool();</div><div class="line">  // 在buffer pool中进行分配</div><div class="line">  var actual = allocPool.write(string, poolOffset, encoding);</div><div class="line">  // 得到一个内存的视图view, 特殊说明: slice不进行copy，仅仅创建view</div><div class="line">  var b = allocPool.slice(poolOffset, poolOffset + actual);</div><div class="line">  poolOffset += actual;</div><div class="line">  // 校验poolOffset是8的整数倍</div><div class="line">  alignPool();</div><div class="line">  return b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// pool的申请</div><div class="line">function createPool() &#123;</div><div class="line">  poolSize = Buffer.poolSize;</div><div class="line">  allocPool = createBuffer(poolSize, true);</div><div class="line">  poolOffset = 0;</div><div class="line">&#125;</div><div class="line">// node加载的时候，就会创建第一个buffer pool</div><div class="line">createPool();</div><div class="line">// 校验poolOffset是8的整数倍</div><div class="line">function alignPool() &#123;</div><div class="line">  // Ensure aligned slices</div><div class="line">  if (poolOffset &amp; 0x7) &#123;</div><div class="line">    poolOffset |= 0x7;</div><div class="line">    poolOffset++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Buffer-TypedArray-Array"><a href="#Buffer-TypedArray-Array" class="headerlink" title="Buffer/TypedArray/Array"></a>Buffer/TypedArray/Array</h4><p>可用从一个现有的Buffer、TypeArray或Array中创建Buffer，内存不会共享，仅仅进行值的copy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var buf1 = new Buffer([1,2,3,4,5]);</div><div class="line">var buf2 = new Buffer(buf1);</div><div class="line">console.log(buf1); // &lt;Buffer 01 02 03 04 05&gt;</div><div class="line">console.log(buf2); // &lt;Buffer 01 02 03 04 05&gt;</div><div class="line">buf1[0] = 16</div><div class="line">console.log(buf1); // &lt;Buffer 10 02 03 04 05&gt;</div><div class="line">console.log(buf2); // &lt;Buffer 01 02 03 04 05&gt;</div></pre></td></tr></table></figure>
<p>上述示例就证明了buf1、buf2没有进行内存的共享，仅仅是值的copy，再从源码层面进行分析:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function fromObject(obj) &#123;</div><div class="line">  // 当obj为Buffer时</div><div class="line">  if (obj instanceof Buffer) &#123;</div><div class="line">    ...</div><div class="line">    const b = allocate(obj.length);</div><div class="line">    obj.copy(b, 0, 0, obj.length);</div><div class="line">    return b;</div><div class="line">  &#125;</div><div class="line">  // 当obj为TypeArray或Array时</div><div class="line">  if (obj) &#123;</div><div class="line">    if (obj.buffer instanceof ArrayBuffer || &apos;length&apos; in obj) &#123;</div><div class="line">      ...</div><div class="line">      return fromArrayLike(obj);</div><div class="line">    &#125;</div><div class="line">    if (obj.type === &apos;Buffer&apos; &amp;&amp; Array.isArray(obj.data)) &#123;</div><div class="line">      return fromArrayLike(obj.data);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  throw new TypeError(kFromErrorMsg);</div><div class="line">&#125;</div><div class="line">// 数组或类数组，逐个进行值的copy</div><div class="line">function fromArrayLike(obj) &#123;</div><div class="line">  const length = obj.length;</div><div class="line">  const b = allocate(length);</div><div class="line">  for (var i = 0; i &lt; length; i++)</div><div class="line">    b[i] = obj[i] &amp; 255;</div><div class="line">  return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc"></a>Buffer.alloc</h3><p>Buffer.alloc用于内存的分配，同时会对内存的旧数据进行覆盖，避免安全隐患的产生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Buffer.alloc = function(size, fill, encoding) &#123;</div><div class="line">  ...</div><div class="line">  if (size &lt;= 0)</div><div class="line">    return createBuffer(size);</div><div class="line">  if (fill !== undefined) &#123;</div><div class="line">    ...</div><div class="line">    return typeof encoding === &apos;string&apos; ?</div><div class="line">        createBuffer(size, true).fill(fill, encoding) :</div><div class="line">        createBuffer(size, true).fill(fill);</div><div class="line">  &#125;</div><div class="line">  return createBuffer(size);</div><div class="line">&#125;;</div><div class="line">function createBuffer(size, noZeroFill) &#123;</div><div class="line">  flags[kNoZeroFill] = noZeroFill ? 1 : 0;</div><div class="line">  try &#123;</div><div class="line">    const ui8 = new Uint8Array(size);</div><div class="line">    Object.setPrototypeOf(ui8, Buffer.prototype);</div><div class="line">    return ui8;</div><div class="line">  &#125; finally &#123;</div><div class="line">    flags[kNoZeroFill] = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码有几个需要注意的点:</p>
<h4 id="先申请后填充"><a href="#先申请后填充" class="headerlink" title="先申请后填充"></a>先申请后填充</h4><p>alloc先通过<code>createBuffer</code>申请一块内存，然后再进行填充，保证申请的内存全部用<code>fill</code>进行填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var buf = Buffer.alloc(10, 11);</div><div class="line">console.log(buf); // &lt;Buffer 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b&gt;</div></pre></td></tr></table></figure>
<h4 id="flags标识"><a href="#flags标识" class="headerlink" title="flags标识"></a>flags标识</h4><p><code>flags</code>用于标识默认的填充值是否为<code>0</code>，该值在javascript中设置，在c++中进行读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// js</div><div class="line">const binding = process.binding(&apos;buffer&apos;);</div><div class="line">const bindingObj = &#123;&#125;;</div><div class="line">...</div><div class="line">binding.setupBufferJS(Buffer.prototype, bindingObj);</div><div class="line">...</div><div class="line">const flags = bindingObj.flags;</div><div class="line">const kNoZeroFill = 0;</div><div class="line"></div><div class="line">// c++</div><div class="line">void SetupBufferJS(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</div><div class="line">  ...</div><div class="line">  Local&lt;Object&gt; bObj = args[1].As&lt;Object&gt;();</div><div class="line">  ...</div><div class="line">  bObj-&gt;Set(String::NewFromUtf8(env-&gt;isolate(), &quot;flags&quot;),</div><div class="line">    Uint32Array::New(array_buffer, 0, fields_count));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Uint8Array"><a href="#Uint8Array" class="headerlink" title="Uint8Array"></a>Uint8Array</h4><p><code>Uint8Array</code>是ES2015 TypeArray中的一种，可以在浏览器中创建二进制数据，这样就把浏览器、Node连接起来。</p>
<h3 id="Buffer-allocUnSafe"><a href="#Buffer-allocUnSafe" class="headerlink" title="Buffer.allocUnSafe"></a>Buffer.allocUnSafe</h3><p>Buffer.allocUnSafe与Buffer.alloc的区别在于，前者是从采用<code>allocate</code>的策略，尝试从<code>buffer pool</code>中申请内存，而<code>buffer pool</code>是不会进行默认值填充的，所以这种行为是不安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Buffer.allocUnsafe = function(size) &#123;</div><div class="line">  assertSize(size);</div><div class="line">  return allocate(size);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Buffer-allocUnsafeSlow"><a href="#Buffer-allocUnsafeSlow" class="headerlink" title="Buffer.allocUnsafeSlow"></a>Buffer.allocUnsafeSlow</h3><p>Buffer.allocUnsafeSlow有两个大特点: 直接通过c++进行内存分配；不会进行旧值填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Buffer.allocUnsafeSlow = function(size) &#123;</div><div class="line">  assertSize(size);</div><div class="line">  return createBuffer(size, true);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Cache和Buffer的区别"><a href="#Cache和Buffer的区别" class="headerlink" title="Cache和Buffer的区别"></a>Cache和Buffer的区别</h2><ul>
<li>Cache：缓存区，是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而  Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能。</li>
</ul>
<p>​    Cache并不是缓存文件的，而是缓存块的(块是I/O读写最小的单元)；Cache一般会用在I/O请求上，如果多个进程要访问某个文件，可以把此文件读入Cache中，这样下一个进程获取CPU控制权并访问此文件直接从Cache读取，提高系统性能。</p>
<ul>
<li>Buffer：缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情。</li>
</ul>
<p>Buffer：一般是用在写入磁盘的，例如：某个进程要求多个字段被读入，当所有要求的字段被读入之前已经读入的字段会先放到buffer中。</p>
<h2 id="Buffer与性能"><a href="#Buffer与性能" class="headerlink" title="Buffer与性能"></a>Buffer与性能</h2><p>Buffer广泛应用于文件I/O和网络I/O,尤其在网络传输，<strong>使用Buffer比直接使用字符串要性能要高很多。在web开发中对于静态内容可以预先转成buffer</strong>,在不需要改变内容时，只读取buffer,不做转换</p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>fs.createReadStream()先在内存中准备一段buffer,然后在fs.read()读取时逐步将磁盘中的字节复制到buffer,读完一次就用slice()从buffer取出部分作为小buffer通过data事件传给调用方。Buffer用完会重新分配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fs.createReadStream(path, opts)</div><div class="line">//参数</div><div class="line">&#123;</div><div class="line">    flags: &apos;r&apos;,</div><div class="line">    encoding: null,</div><div class="line">    fd: null,</div><div class="line">    mode: 0666,</div><div class="line">    highWaterMark: 64 * 1024 // 每次读取的长度</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重新分配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var pool;//常驻内存</div><div class="line"></div><div class="line">function allocNewPool(poolSize) &#123;</div><div class="line">    pool = new Buffer(poolSize);</div><div class="line">    pool.used = 0;</div><div class="line">&#125;</div><div class="line">//当pool剩余数量小于128(kMinPoolSpace)字节时，会重新分配</div><div class="line">if (!pool || pool.length - pool.used &lt; kMinPoolSpace) &#123; </div><div class="line">// discard the old pool</div><div class="line">    pool = null;</div><div class="line">    allocNewPool(this._readableState.highWaterMark);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>highWaterMark的大小对性能的影响有：<strong>buffer内存的分配和使用、系统调用次数</strong>;</p>
<ul>
<li>文件流读取基于buffer,buffer基于slowbuffer，文件小于8kb可能造成slab浪费</li>
<li>fs.createReadStream()内部使用fs.read()，会引起系统对磁盘的调用，highWaterMark的大小决定调用次数和data事件次数</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"># node</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/27/MongoDB文档查询find/" rel="next" title="MongoDB文档查询find()">
                <i class="fa fa-chevron-left"></i> MongoDB文档查询find()
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/30/ES6之二进制数组详解/" rel="prev" title="ES6之二进制数组详解">
                ES6之二进制数组详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/IMG_2036.JPG"
               alt="大闯仔儿" />
          <p class="site-author-name" itemprop="name">大闯仔儿</p>
           
              <p class="site-description motion-element" itemprop="description">世界那么大，谁不想去看看！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">68</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tages/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#buffer的基本使用"><span class="nav-number">1.</span> <span class="nav-text">buffer的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#buffer的结构"><span class="nav-number">2.</span> <span class="nav-text">buffer的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配策略"><span class="nav-number">3.</span> <span class="nav-text">内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-from"><span class="nav-number">3.1.</span> <span class="nav-text">Buffer.from</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBuffer的实例"><span class="nav-number">3.1.1.</span> <span class="nav-text">ArrayBuffer的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string"><span class="nav-number">3.1.2.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer-TypedArray-Array"><span class="nav-number">3.1.3.</span> <span class="nav-text">Buffer/TypedArray/Array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-alloc"><span class="nav-number">3.2.</span> <span class="nav-text">Buffer.alloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先申请后填充"><span class="nav-number">3.2.1.</span> <span class="nav-text">先申请后填充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flags标识"><span class="nav-number">3.2.2.</span> <span class="nav-text">flags标识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Uint8Array"><span class="nav-number">3.2.3.</span> <span class="nav-text">Uint8Array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-allocUnSafe"><span class="nav-number">3.3.</span> <span class="nav-text">Buffer.allocUnSafe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-allocUnsafeSlow"><span class="nav-number">3.4.</span> <span class="nav-text">Buffer.allocUnsafeSlow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache和Buffer的区别"><span class="nav-number">4.</span> <span class="nav-text">Cache和Buffer的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer与性能"><span class="nav-number">5.</span> <span class="nav-text">Buffer与性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件读取"><span class="nav-number">5.1.</span> <span class="nav-text">文件读取</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大闯仔儿</span>
</div>



<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
<!-- 背景动画 -->
<script type="text/javascript" src="/js/src/particle.js"></script>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

